
def astar(start, goal):
    open_list = [start]
    came_from = {}
    g = {start: 0}
    f = {start: abs(start[0] - goal[0]) + abs(start[1] - goal[1])}

    while open_list:
        # Pick node with lowest f score
        current = min(open_list, key=lambda x: f[x])

        if current == goal:
            # Reconstruct path
            path = []
            while current in came_from:
                path.append(current)
                current = came_from[current]
            path.append(start)
            return path[::-1]  # reverse

        open_list.remove(current)

        # Neighbor moves (4-directional)
        for move in [(0,1),(1,0),(0,-1),(-1,0)]:
            neighbor = (current[0] + move[0], current[1] + move[1])

            # Ignore invalid positions (outside 0â€“4 range)
            if not (0 <= neighbor[0] <= 4 and 0 <= neighbor[1] <= 4):
                continue

            tentative_g = g[current] + 1
            if neighbor not in g or tentative_g < g[neighbor]:
                came_from[neighbor] = current
                g[neighbor] = tentative_g
                f[neighbor] = tentative_g + abs(neighbor[0] - goal[0]) + abs(neighbor[1] - goal[1])
                if neighbor not in open_list:
                    open_list.append(neighbor)

    return None  # No path found


# Example usage
start = (0, 0)
goal = (4, 4)
path = astar(start, goal)
print("Path:", path)
